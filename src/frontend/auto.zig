//! datatypes for autogenerated parsing

const std = @import("std");
const builtin = @import("builtin");

pub const Precedence = struct {
    power: usize,
    /// for binary ops
    right: bool = false,
};

/// used by parseForm to encode syntax
pub const FormExpr = union(enum) {
    pub const Flag = enum { one, maybe, any, multi };

    const Allowed = std.BoundedArray(Form, 4);

    pub const Expr = struct {
        // a number of allowed forms
        allowed: Allowed,
        flag: Flag,
    };

    expr: Expr,
    keyword: []const u8,

    fn expr(allowed: Allowed, flag: Flag) @This() {
        return .{ .expr = .{ .allowed = allowed, .flag = flag } };
    }
};

pub const Syntax = struct {
    const Self = @This();

    pub const Kind = enum {
        prefixed, // begins with a keyword
        binary,
        unfixed, // begins + ends with exprs
    };

    form: Form,
    prec: Precedence,
    fexprs: []const FormExpr,
    kind: Kind,

    fn init(form: Form, prec: Precedence, comptime str: []const u8) Self {
        const fexprs = &parseFormExprs(str);
        std.debug.assert(fexprs.len > 0);

        const is_binary = fexprs.len == 3
                      and fexprs[0] == .expr
                      and fexprs[1] == .keyword
                      and fexprs[2] == .expr;

        const kind: Kind =
            if (is_binary) .binary
            else if (fexprs[0] == .keyword) .prefixed
            else .unfixed;

        return Self{
            .form = form,
            .prec = prec,
            .fexprs = fexprs,
            .kind = kind
        };
    }
};

fn countFormExprs(comptime str: []const u8) usize {
    comptime {
        var count: usize = 0;
        var iter = std.mem.tokenize(u8, str, " ");
        while (iter.next() != null) {
            count += 1;
        }

        return count;
    }
}

fn badFormExpr(comptime str: [] const u8) noreturn {
    @compileError("`" ++ str ++ "` is not a form expr");
}

/// parses a formexpr at comptime.
///
/// str is a series of tokens separated by spaces. each token can be:
/// - a keyword
/// - `<>` -- parses any expression
/// - `<form0 form1 ... formN>` -- pases a
///
/// `<>` forms can be followed by a flag:
/// - `?` -- zero or one expr
/// - `*` -- zero or more exprs
/// - `+` -- one or more exprs
///
/// see SYNTAX_TABLE for examples
fn parseFormExprs(comptime str: []const u8) [countFormExprs(str)]FormExpr {
    comptime {
        @setEvalBranchQuota(100_000);

        var fexprs: [countFormExprs(str)]FormExpr = undefined;
        var i: usize = 0;

        var iter = std.mem.tokenize(u8, str, " ");
        while (iter.next()) |tok| : (i += 1) {
            if (KEYWORDS.has(tok)) {
                fexprs[i] = .{ .keyword = tok };
            } else {
                // get flag and inner expr
                const flag: FormExpr.Flag = switch (tok[tok.len - 1]) {
                    '*' => .any,
                    '+' => .multi,
                    '>' => .one,
                    '?' => .maybe,
                    else => badFormExpr(tok)
                };

                if (flag != .one and tok[tok.len - 2] != '>') {
                    badFormExpr(tok);
                }

                const inner = tok[1..tok.len - 1 - @boolToInt(flag != .one)];

                // parse inner expr
                var forms = FormExpr.Allowed{};

                var inner_iter = std.mem.tokenize(u8, inner, "|");
                while (inner_iter.next()) |name| {
                    const form = Form.map.get(name) orelse {
                        @compileError("unknown form `" ++ name ++ "`");
                    };

                    forms.appendAssumeCapacity(form);
                }

                fexprs[i] = FormExpr.expr(forms, flag);
            }
        }

        return fexprs;
    }
}

fn tableWhereCount(comptime kind: Syntax.Kind) usize {
    comptime {
        // count entries
        var count: usize = 0;
        for (SYNTAX_TABLE) |syntax| {
            count += @boolToInt(syntax.kind == kind);
        }

        return count;
    }
}

fn tableWhere(comptime kind: Syntax.Kind) [tableWhereCount(kind)]Syntax {
    comptime {
        const count = tableWhereCount(kind);

        var arr: [count]Syntax = undefined;
        var i: usize = 0;
        for (SYNTAX_TABLE) |syntax| {
            if (syntax.kind == kind) {
                arr[i] = syntax;
                i += 1;
            }
        }

        return arr;
    }
}

// tables ======================================================================

pub const Form = enum {
    file,
    call,
    list,

    dot,
    anno,
    dict,
    seq,

    // no children
    unit,
    number,
    string,
    symbol,

    // math
    add,
    sub,
    mul,
    div,
    mod,

    // conditions
    eq,
    gt,
    lt,
    ge,
    le,

    // ptrs
    addr,

    // flow
    stmt,
    @"if",
    @"fn",
    def,

    /// maps tagName to enum value. used for parsing form exprs.
    const map = map: {
        const arr = std.enums.values(Form);

        const KV = struct {
            @"0": []const u8,
            @"1": Form,
        };

        var kvs: [arr.len]KV = undefined;
        for (arr) |tag, i| {
            kvs[i] = KV{
                .@"0" = @tagName(tag),
                .@"1" = tag,
            };
        }

        break :map std.ComptimeStringMap(Form, kvs);
    };

    /// used for generating error messages etc.
    pub fn name(self: Form) []const u8 {
        return switch (self) {
            .file, .call, .list, .unit, .symbol, .string, .number
                => @tagName(self),
            .dict => "dictionary literal",
            .seq => "sequence",
            .anno => "annotation",
            .dot => "field access (`.`) operator",
            .add => "addition",
            .sub => "subtraction",
            .mul => "multiplication",
            .div => "division",
            .mod => "modulus",
            .eq => "equality",
            .gt => "greater than operator",
            .lt => "less than operator",
            .ge => "greater than or equals operator",
            .le => "less than or equals operator",
            .addr => "address operator",
            .stmt => "statement expression",
            .@"if" => "if expression",
            .@"fn" => "fn expression",
            .def => "declaration",
        };
    }
};

pub const KEYWORDS = kw: {
    const list = [_][]const u8{
        ".", ";", "=", ":", ",", "->",
        // math
        "+", "-", "*", "/", "%",
        // comparisons
        "==", ">", "<", ">=", "<=",
        // ptrs
        "&",
        // matched
        "(", ")", "[", "]", "{", "}",
        // words
        "if", "then", "else", "def", "fn",
    };

    // manipulate so it's consumable by ComptimeStringMap
    const KV = struct {
        @"0": []const u8,
        @"1": void = {},
    };
    var kvs: [list.len]KV = undefined;
    for (list) |keyword, i| {
        kvs[i] = KV{ .@"0" = keyword };
    }

    break :kw std.ComptimeStringMap(void, kvs);
};

pub const PRECEDENCES = struct {
    const P = Precedence;

    pub const DEFAULT        = P{ .power = 0 };
    pub const STATEMENT      = P{ .power = 1, .right = true };
    pub const SEQUENCE       = P{ .power = 2, .right = true };
    pub const ANNOTATION     = P{ .power = 3 };
    pub const COMPARISON     = P{ .power = 4 };
    pub const ADDITIVE       = P{ .power = 5 };
    pub const MULTIPLICATIVE = P{ .power = 6 };
    pub const CALL           = P{ .power = 8 };
    pub const POINTER        = P{ .power = 9 };
    pub const FIELD_ACCESS   = P{ .power = 10 };
};

/// the definition of fluent syntax
pub const SYNTAX_TABLE = table: {
    const P = PRECEDENCES;
    const x = Syntax.init;

    break :table [_]Syntax{
        x(.dict,  P.DEFAULT,        "{ <anno|seq>? }"),
        x(.list,  P.DEFAULT,        "[ <>? ]"),
        x(.@"if", P.DEFAULT,        "if <> then <> else <>"),
        x(.@"fn", P.DEFAULT,        "fn <dict> -> <> = <>"),
        x(.def,   P.DEFAULT,        "def <symbol|anno> = <> ; ;"),

        x(.stmt,  P.STATEMENT,      "<> ; <>"),

        x(.seq,   P.SEQUENCE,       "<> , <>"),

        x(.anno,  P.ANNOTATION,     "<symbol> : <>"),

        x(.eq,    P.COMPARISON,     "<> == <>"),
        x(.gt,    P.COMPARISON,     "<> > <>"),
        x(.lt,    P.COMPARISON,     "<> < <>"),
        x(.ge,    P.COMPARISON,     "<> >= <>"),
        x(.le,    P.COMPARISON,     "<> <= <>"),

        x(.add,   P.ADDITIVE,       "<> + <>"),
        x(.sub,   P.ADDITIVE,       "<> - <>"),

        x(.mul,   P.MULTIPLICATIVE, "<> * <>"),
        x(.div,   P.MULTIPLICATIVE, "<> / <>"),
        x(.mod,   P.MULTIPLICATIVE, "<> % <>"),

        // CALL precedence goes here

        x(.addr,  P.POINTER,        "& <>"),

        x(.dot,   P.FIELD_ACCESS,   "<> . <>"),
    };
};

/// a ComptimeStringMap(Syntax) where the key is the prefix keyword
pub const PREFIXED_SYNTAX = map: {
    const arr = tableWhere(.prefixed);

    const KV = struct {
        @"0": []const u8,
        @"1": Syntax,
    };

    var kvs: [arr.len]KV = undefined;
    for (arr) |syntax, i| {
        kvs[i] = KV{
            .@"0" = syntax.fexprs[0].keyword,
            .@"1" = syntax,
        };
    }

    break :map std.ComptimeStringMap(Syntax, kvs);
};

/// a ComptimeStringMap(Syntax) where the key is the binary operator keyword
pub const BINARY_SYNTAX = map: {
    const arr = tableWhere(.binary);

    const KV = struct {
        @"0": []const u8,
        @"1": Syntax,
    };

    var kvs: [arr.len]KV = undefined;
    for (arr) |syntax, i| {
        kvs[i] = KV{
            .@"0" = syntax.fexprs[1].keyword,
            .@"1" = syntax,
        };
    }

    break :map std.ComptimeStringMap(Syntax, kvs);
};