//! datatypes for autogenerated parsing

const std = @import("std");
const builtin = @import("builtin");

pub const Form = enum {
    file,
    call,
    list,

    parens,
    dot,
    anno,
    dict,
    seq,

    // no children
    unit,
    number,
    string,
    symbol,

    // math
    add,
    sub,
    mul,
    div,
    mod,

    // conditions
    eq,
    gt,
    lt,
    ge,
    le,

    // ptrs
    addr,

    // flow
    stmt,
    @"if",
    @"fn",
    def,

    /// maps tagName to enum value. used for parsing form exprs.
    const map = map: {
        const arr = std.enums.values(Form);

        const KV = struct {
            @"0": []const u8,
            @"1": Form,
        };

        var kvs: [arr.len]KV = undefined;
        for (arr) |tag, i| {
            kvs[i] = KV{
                .@"0" = @tagName(tag),
                .@"1" = tag,
            };
        }

        break :map std.ComptimeStringMap(Form, kvs);
    };

    /// used for generating error messages etc.
    pub fn name(self: Form) []const u8 {
        return switch (self) {
            .file, .call, .list, .unit, .symbol, .string, .number
                => @tagName(self),
            .parens => "parentheses",
            .dict => "dictionary literal",
            .seq => "sequence",
            .anno => "annotation",
            .dot => "field access",
            .add => "add operator",
            .sub => "subtract operator",
            .mul => "multiply operator",
            .div => "divide operator",
            .mod => "modulus operator",
            .eq => "equality operator",
            .gt => "greater than operator",
            .lt => "less than operator",
            .ge => "greater than or equals operator",
            .le => "less than or equals operator",
            .addr => "address of operator",
            .stmt => "statement expression",
            .@"if" => "if expression",
            .@"fn" => "fn expression",
            .def => "declaration",
        };
    }
};

/// used by parseForm to encode syntax
pub const FormExpr = union(enum) {
    const Self = @This();

    pub const Flag = enum { one, opt, any, multi };

    pub const Expr = struct {
        flag: Flag = .one,
        /// if an expr is contained, it resets the climbing precedence.
        /// otherwise, exprs here must match or exceed the current precedence
        container: bool = false,
    };

    expr: Expr,
    word: []const u8, // TODO use common.Symbol

    /// whether this fexpr represents this word
    pub fn isWord(self: Self, word: []const u8) bool {
        return self == .word and std.mem.eql(u8, word, self.word);
    }

    pub fn format(
        self: Self,
        comptime _: []const u8,
        _: std.fmt.FormatOptions,
        writer: anytype,
    ) @TypeOf(writer).Error!void {
        switch (self) {
            .expr => |expr| {
                if (expr.container) {
                    try writer.writeAll("<>");
                } else {
                    try writer.writeByte('$');
                }

                try writer.writeAll(switch (expr.flag) {
                    .one => "",
                    .opt => "?",
                    .any => "*",
                    .multi => "+",
                });
            },
            .word => |word| {
                try writer.writeByte('`');
                try writer.writeAll(word);
            }
        }
    }
};

pub const Syntax = struct {
    const Self = @This();

    pub const Direction = enum { left, right };

    form: Form,
    dir: Direction,
    fexprs: []const FormExpr,

    fn fexprsCount(comptime str: []const u8) usize {
        var count: usize = 0;
        var tokens = std.mem.tokenize(u8, str, " ");
        while (tokens.next()) |_| {
            count += 1;
        }

        return count;
    }

    fn badModifier(comptime tok: []const u8) noreturn {
        @compileError("`" ++ tok[1..] ++ "` is not a valid modifier");
    }

    fn parseFormExpr(comptime tok: []const u8) FormExpr {
        comptime {
            return switch (tok[0]) {
                '`' => word: {
                    const word = tok[1..];
                    if (!SYMBOLS.has(word) and !KEYWORDS.has(word)) {
                        @compileError(
                            "`" ++ word ++ "` is not a symbol or keyword"
                        );
                    }

                    break :word FormExpr{ .word = word };
                },
                '$' => switch (tok.len) {
                    1 => FormExpr{ .expr = .{} },
                    2 => FormExpr{
                        .expr = .{
                            .flag = switch (tok[1]) {
                                '?' => .opt,
                                '*' => .any,
                                '+' => .multi,
                                else => badModifier(tok)
                            },
                        }
                    },
                    else => badModifier(tok)
                },
                else => {
                    @compileError("`" ++ tok ++ "` is not a valid FormExpr");
                }
            };
        }
    }

    /// compiles a series of expressions separated by spaces. expression can
    /// be:
    /// - '`' followed by a keyword or symbol
    /// - '$' representing a child expr, followed by one of '*', '?', or '+'
    ///   which represent their regex counterparts
    fn parseForm(comptime str: []const u8) [fexprsCount(str)]FormExpr {
        comptime {
            var fexprs: [fexprsCount(str)]FormExpr = undefined;
            var index: usize = 0;

            var tokens = std.mem.tokenize(u8, str, " ");
            while (tokens.next()) |tok| : (index += 1) {
                fexprs[index] = parseFormExpr(tok);

                // currently I'm not using the modifiers
                if (fexprs[index] == .expr
                and fexprs[index].expr.flag != .one) {
                    @compileError("sorry, flags don't work right now!");
                }
            }

            // second pass to find contained exprs
            var i: usize = 1;
            while (i < fexprs.len - 1) : (i += 1) {
                const is_container = fexprs[i] == .expr
                                 and fexprs[i - 1] == .word
                                 and fexprs[i + 1] == .word;

                if (is_container) {
                    fexprs[i].expr.container = true;
                }
            }

            return fexprs;
        }
    }

    pub fn init(form: Form, dir: Direction, comptime syntax: []const u8) Self {
        return Self{
            .form = form,
            .dir = dir,
            .fexprs = &parseForm(syntax),
        };
    }

    pub fn format(
        self: Self,
        comptime _: []const u8,
        _: std.fmt.FormatOptions,
        writer: anytype,
    ) @TypeOf(writer).Error!void {
        try writer.print(
            "[{s} {c}]",
            .{@tagName(self.form), @tagName(self.dir)[0]}
        );

        for (self.fexprs) |fexpr| {
            try writer.print(" {}", .{fexpr});
        }
    }
};

/// syntax organized by precedence in ascending order
pub const SYNTAX = t: {
    const x = Syntax.init;
    break :t &[_][]const Syntax {
        &.{
            x(.parens, .left,  "`( $ `)"),
            x(.@"if",  .right, "`if $ `then $ `else $"),
        },
        &.{
            x(.add,    .left,  "$ `+ $"),
            x(.sub,    .left,  "$ `- $"),
        },
        &.{
            x(.mul,    .left,  "$ `* $"),
            x(.div,    .left,  "$ `/ $"),
            x(.mod,    .left,  "$ `% $"),
        },
    };
};

fn comptimeStringSet(comptime list: []const []const u8) type {
    comptime {
        // manipulate so it's consumable by ComptimeStringMap
        const KV = struct {
            @"0": []const u8,
            @"1": void = {},
        };
        var kvs: [list.len]KV = undefined;
        for (list) |keyword, i| {
            kvs[i] = KV{ .@"0" = keyword };
        }

        return std.ComptimeStringMap(void, kvs);
    }
}

const KEYWORD_LIST = &[_][]const u8{
    "=", "+", "-", "*", "/", "%",
    "==", ">", "<", ">=", "<=",
    "if", "then", "else", "def", "fn",
};

const SYMBOL_LIST = &[_][]const u8{
    "(", ")", "[", "]", "{", "}",
    "&", ".", ",", ";", ":",
    "->",
};

pub const KEYWORDS = comptimeStringSet(KEYWORD_LIST);
pub const SYMBOLS = comptimeStringSet(SYMBOL_LIST);

pub const MAX_SYMBOL_LEN = max: {
    var max: usize = 0;
    for (SYMBOL_LIST) |sym| {
        max = @max(max, sym.len);
    }

    break :max max;
};