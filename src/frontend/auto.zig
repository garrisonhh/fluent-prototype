//! datatypes for autogenerated parsing

const std = @import("std");
const builtin = @import("builtin");

pub const Precedence = struct {
    power: usize,
    /// for binary ops
    right: bool = false,
};

/// used by parseForm to encode syntax
pub const FormExpr = union(enum) {
    pub const Flag = enum { one, any, multi };

    pub const Expr = struct {
        form: ?Form,
        flag: Flag,
    };

    expr: Expr,
    keyword: []const u8,

    fn expr(form: ?Form, flag: Flag) @This() {
        return .{ .expr = .{ .form = form, .flag = flag } };
    }
};

pub const Syntax = struct {
    const Self = @This();

    pub const Kind = enum {
        prefixed, // begins with a keyword
        binary,
        unfixed, // begins + ends with exprs
    };

    form: Form,
    prec: Precedence,
    fexprs: []const FormExpr,
    kind: Kind,

    fn init(form: Form, prec: Precedence, comptime str: []const u8) Self {
        const fexprs = &parseFormExprs(str);
        std.debug.assert(fexprs.len > 0);

        const is_binary = fexprs.len == 3
                      and fexprs[0] == .expr
                      and fexprs[1] == .keyword
                      and fexprs[2] == .expr;

        const kind: Kind =
            if (is_binary) .binary
            else if (fexprs[0] == .keyword) .prefixed
            else .unfixed;

        return Self{
            .form = form,
            .prec = prec,
            .fexprs = fexprs,
            .kind = kind
        };
    }
};

fn countFormExprs(comptime str: []const u8) usize {
    comptime {
        var count: usize = 0;
        var iter = std.mem.tokenize(u8, str, " ");
        while (iter.next() != null) {
            count += 1;
        }

        return count;
    }
}

fn badFormExpr(comptime str: [] const u8) noreturn {
    @compileError("`" ++ str ++ "` is not a form expr");
}

/// parses a formexpr at comptime.
///
/// str is a series of tokens separated by spaces. each token can be:
/// - a keyword
/// - `<>` -- parses any expression
/// - `<form-name>` -- parses an expression which must be the form form-name
///
/// `<>` forms can be followed by `*` to indicate zero or more, and `+` to
/// indicate one or more
///
/// see SYNTAX_TABLE for examples
fn parseFormExprs(comptime str: []const u8) [countFormExprs(str)]FormExpr {
    comptime {
        @setEvalBranchQuota(100_000);

        var fexprs: [countFormExprs(str)]FormExpr = undefined;
        var i: usize = 0;

        var iter = std.mem.tokenize(u8, str, " ");
        while (iter.next()) |tok| : (i += 1) {
            if (KEYWORDS.has(tok)) {
                fexprs[i] = .{ .keyword = tok };
            } else {
                // get flag and inner expr
                const flag: FormExpr.Flag = switch (tok[tok.len - 1]) {
                    '*' => .any,
                    '+' => .multi,
                    '>' => .one,
                    else => badFormExpr(tok)
                };

                if (flag != .one and tok[tok.len - 2] != '>') {
                    badFormExpr(tok);
                }

                const inner = tok[1..tok.len - 1 - @boolToInt(flag != .one)];

                // parse inner expr
                const form: ?Form =
                    if (inner.len == 0) null
                    else if (Form.map.get(inner)) |tag| tag
                    else {
                        badFormExpr(inner);
                    };

                fexprs[i] = FormExpr.expr(form, flag);
            }
        }

        return fexprs;
    }
}

fn tableWhereCount(comptime kind: Syntax.Kind) usize {
    comptime {
        // count entries
        var count: usize = 0;
        for (SYNTAX_TABLE) |syntax| {
            count += @boolToInt(syntax.kind == kind);
        }

        return count;
    }
}

fn tableWhere(comptime kind: Syntax.Kind) [tableWhereCount(kind)]Syntax {
    comptime {
        const count = tableWhereCount(kind);

        var arr: [count]Syntax = undefined;
        var i: usize = 0;
        for (SYNTAX_TABLE) |syntax| {
            if (syntax.kind == kind) {
                arr[i] = syntax;
                i += 1;
            }
        }

        return arr;
    }
}

// tables ======================================================================

pub const Form = enum {
    // special
    file,
    call,
    list,

    // no children
    unit,
    number,
    string,
    symbol,

    // general ops
    dot,
    anno,

    // math
    add,
    sub,
    mul,
    div,
    mod,

    // conditions
    eq,
    gt,
    lt,
    ge,
    le,

    // ptrs
    addr,

    // flow
    stmt,
    @"if",

    /// maps tagName to enum value. used for parsing form exprs.
    const map = map: {
        const arr = std.enums.values(Form);

        const KV = struct {
            @"0": []const u8,
            @"1": Form,
        };

        var kvs: [arr.len]KV = undefined;
        for (arr) |tag, i| {
            kvs[i] = KV{
                .@"0" = @tagName(tag),
                .@"1" = tag,
            };
        }

        break :map std.ComptimeStringMap(Form, kvs);
    };

    /// used for generating error messages etc.
    pub fn name(self: Form) []const u8 {
        return switch (self) {
            .file, .call, .list, .unit, .symbol, .string, .number
                => @tagName(self),
            .anno => "annotation",
            .dot => "field access (`.`) operator",
            .add => "addition",
            .sub => "subtraction",
            .mul => "multiplication",
            .div => "division",
            .mod => "modulus",
            .eq => "equality",
            .gt => "greater than operator",
            .lt => "less than operator",
            .ge => "greater than or equals operator",
            .le => "less than or equals operator",
            .addr => "address operator",
            .stmt => "statement expression",
            .@"if" => "if expression",
        };
    }
};

pub const KEYWORDS = kw: {
    const list = [_][]const u8{
        ".", ";", "=", ":",
        // math
        "+", "-", "*", "/", "%",
        // comparisons
        "==", ">", "<", ">=", "<=",
        // ptrs
        "&",
        // parens
        "(", ")",
        // lists
        "[", "]",
        // dicts
        "{", "}",
        // if
        "if", "then", "else"
    };

    // manipulate so it's consumable by ComptimeStringMap
    const KV = struct {
        @"0": []const u8,
        @"1": void = {},
    };
    var kvs: [list.len]KV = undefined;
    for (list) |keyword, i| {
        kvs[i] = KV{ .@"0" = keyword };
    }

    break :kw std.ComptimeStringMap(void, kvs);
};

/// the definition of fluent syntax
/// (this is a [_]Syntax)
pub const SYNTAX_TABLE = table: {
    // precedences
    const P = Precedence;

    const LOWEST         = P{ .power = 0 };
    const STATEMENT      = P{ .power = 1, .right = true };
    const ANNOTATION     = P{ .power = 2 };
    const COMPARISON     = P{ .power = 3 };
    const ADDITIVE       = P{ .power = 4 };
    const MULTIPLICATIVE = P{ .power = 5 };
    const POINTER        = P{ .power = 6 };

    // syntax definitions
    const x = Syntax.init;
    break :table [_]Syntax{
        x(.@"if", LOWEST,         "if <> then <> else <>"),

        x(.stmt,  STATEMENT,      "<symbol> ; <>"),

        x(.anno,  ANNOTATION,     "<> : <>"),

        x(.eq,    COMPARISON,     "<> == <>"),
        x(.gt,    COMPARISON,     "<> > <>"),
        x(.lt,    COMPARISON,     "<> < <>"),
        x(.ge,    COMPARISON,     "<> >= <>"),
        x(.le,    COMPARISON,     "<> <= <>"),

        x(.add,   ADDITIVE,       "<> + <>"),
        x(.sub,   ADDITIVE,       "<> - <>"),

        x(.mul,   MULTIPLICATIVE, "<> * <>"),
        x(.div,   MULTIPLICATIVE, "<> / <>"),
        x(.mod,   MULTIPLICATIVE, "<> % <>"),

        x(.addr,  POINTER,        "& <>"),
    };
};

/// a ComptimeStringMap(Syntax) where the key is the prefix keyword
pub const PREFIXED_SYNTAX = map: {
    const arr = tableWhere(.prefixed);

    const KV = struct {
        @"0": []const u8,
        @"1": Syntax,
    };

    var kvs: [arr.len]KV = undefined;
    for (arr) |syntax, i| {
        kvs[i] = KV{
            .@"0" = syntax.fexprs[0].keyword,
            .@"1" = syntax,
        };
    }

    break :map std.ComptimeStringMap(Syntax, kvs);
};

/// a ComptimeStringMap(Syntax) where the key is the binary operator keyword
pub const BINARY_SYNTAX = map: {
    const arr = tableWhere(.binary);

    const KV = struct {
        @"0": []const u8,
        @"1": Syntax,
    };

    var kvs: [arr.len]KV = undefined;
    for (arr) |syntax, i| {
        kvs[i] = KV{
            .@"0" = syntax.fexprs[1].keyword,
            .@"1" = syntax,
        };
    }

    break :map std.ComptimeStringMap(Syntax, kvs);
};