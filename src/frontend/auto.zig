//! datatypes for autogenerated parsing

const std = @import("std");
const builtin = @import("builtin");

pub const Form = enum {
    file,
    call,
    list,

    parens,
    dot,
    anno,
    dict,
    seq,

    // no children
    unit,
    number,
    string,
    symbol,

    // math
    add,
    sub,
    mul,
    div,
    mod,

    // conditions
    eq,
    gt,
    lt,
    ge,
    le,

    // ptrs
    addr,

    // flow
    stmt,
    @"if",
    @"fn",
    def,

    /// maps tagName to enum value. used for parsing form exprs.
    const map = map: {
        const arr = std.enums.values(Form);

        const KV = struct {
            @"0": []const u8,
            @"1": Form,
        };

        var kvs: [arr.len]KV = undefined;
        for (arr) |tag, i| {
            kvs[i] = KV{
                .@"0" = @tagName(tag),
                .@"1" = tag,
            };
        }

        break :map std.ComptimeStringMap(Form, kvs);
    };

    /// used for generating error messages etc.
    pub fn name(self: Form) []const u8 {
        return switch (self) {
            .file, .call, .list, .unit, .symbol, .string, .number
                => @tagName(self),
            .parens => "parentheses",
            .dict => "dictionary literal",
            .seq => "sequence",
            .anno => "annotation",
            .dot => "field access",
            .add => "add operator",
            .sub => "subtract operator",
            .mul => "multiply operator",
            .div => "divide operator",
            .mod => "modulus operator",
            .eq => "equality operator",
            .gt => "greater than operator",
            .lt => "less than operator",
            .ge => "greater than or equals operator",
            .le => "less than or equals operator",
            .addr => "address of operator",
            .stmt => "statement expression",
            .@"if" => "if expression",
            .@"fn" => "fn expression",
            .def => "declaration",
        };
    }
};

/// used by parseForm to encode syntax
pub const FormExpr = union(enum) {
    const Self = @This();

    pub const Flag = enum { one, opt, any, multi };
    pub const ClimbBehavior = enum { same, increase, reset };

    pub const Expr = struct {
        flag: Flag = .one,
        behavior: ClimbBehavior = .same,

        pub fn innerPrec(self: @This(), prec: usize) usize {
            return switch (self.behavior) {
                .same => prec,
                .increase => prec + 1,
                .reset => 0,
            };
        }
    };

    expr: Expr,
    word: []const u8, // TODO use common.Symbol

    /// whether this fexpr represents this word
    pub fn isWord(self: Self, word: []const u8) bool {
        return self == .word and std.mem.eql(u8, word, self.word);
    }

    pub fn format(
        self: Self,
        comptime _: []const u8,
        _: std.fmt.FormatOptions,
        writer: anytype,
    ) @TypeOf(writer).Error!void {
        switch (self) {
            .expr => |expr| {
                try writer.writeByte('$');

                try writer.writeAll(switch (expr.behavior) {
                    .same => "",
                    .increase => "+",
                    .reset => "0",
                });

                try writer.writeAll(switch (expr.flag) {
                    .one => "",
                    .opt => "?",
                    .any => "*",
                    .multi => "+",
                });
            },
            .word => |word| {
                try writer.writeByte('`');
                try writer.writeAll(word);
            }
        }
    }
};

pub const Syntax = struct {
    const Self = @This();

    const Direction = enum { l, r };

    form: Form,
    fexprs: []const FormExpr,

    fn fexprsCount(comptime str: []const u8) usize {
        var count: usize = 0;
        var tokens = std.mem.tokenize(u8, str, " ");
        while (tokens.next()) |_| {
            count += 1;
        }

        return count;
    }

    fn badModifier(comptime tok: []const u8) noreturn {
        @compileError("`" ++ tok[1..] ++ "` is not a valid modifier");
    }

    fn parseFormExpr(comptime tok: []const u8) FormExpr {
        comptime {
            return switch (tok[0]) {
                '`' => word: {
                    const word = tok[1..];
                    if (!SYMBOLS.has(word) and !KEYWORDS.has(word)) {
                        @compileError(
                            "`" ++ word ++ "` is not a symbol or keyword"
                        );
                    }

                    break :word FormExpr{ .word = word };
                },
                '$' => switch (tok.len) {
                    1 => FormExpr{ .expr = .{} },
                    2 => FormExpr{
                        .expr = .{
                            .flag = switch (tok[1]) {
                                '?' => .opt,
                                '*' => .any,
                                '+' => .multi,
                                else => badModifier(tok)
                            },
                        }
                    },
                    else => badModifier(tok)
                },
                else => {
                    @compileError("`" ++ tok ++ "` is not a valid FormExpr");
                }
            };
        }
    }

    /// compiles a series of expressions separated by spaces. expression can
    /// be:
    /// - '`' followed by a keyword or symbol
    /// - '$' representing a child expr, followed by one of '*', '?', or '+'
    ///   which represent their regex counterparts
    fn parseForm(
        comptime dir: Direction,
        comptime str: []const u8
    ) [fexprsCount(str)]FormExpr {
        comptime {
            var fexprs: [fexprsCount(str)]FormExpr = undefined;
            var index: usize = 0;

            var tokens = std.mem.tokenize(u8, str, " ");
            while (tokens.next()) |tok| : (index += 1) {
                fexprs[index] = parseFormExpr(tok);

                // currently I'm not using the modifiers
                if (fexprs[index] == .expr
                and fexprs[index].expr.flag != .one) {
                    @compileError("sorry, flags don't work right now!");
                }
            }

            // directions are handled by changing the precedence climbing rule
            // for LR or RR exprs to ignore all same-precedence rules. this is
            // so that the parser doesn't have to understand directions
            const inc_index = switch (dir) {
                .l => fexprs.len - 1,
                .r => 0,
            };

            if (fexprs[inc_index] == .expr) {
                fexprs[inc_index].expr.behavior = .increase;
            }

            // if an expression is inside of two keywords, it is a 'container'
            // and precedence should be reset when parsing it
            var i: usize = 1;
            while (i < fexprs.len - 1) : (i += 1) {
                const is_container = fexprs[i] == .expr
                                 and fexprs[i - 1] == .word
                                 and fexprs[i + 1] == .word;

                if (is_container) {
                    fexprs[i].expr.behavior = .reset;
                }
            }

            return fexprs;
        }
    }

    pub fn init(
        form: Form,
        comptime dir: Direction,
        comptime syntax: []const u8
    ) Self {
        return Self{
            .form = form,
            .fexprs = &parseForm(dir, syntax),
        };
    }

    pub fn format(
        self: Self,
        comptime _: []const u8,
        _: std.fmt.FormatOptions,
        writer: anytype,
    ) @TypeOf(writer).Error!void {
        try writer.print("[{s}]", .{@tagName(self.form)});

        for (self.fexprs) |fexpr| {
            try writer.print(" {}", .{fexpr});
        }
    }
};

/// syntax organized by precedence in ascending order
pub const SYNTAX = t: {
    const x = Syntax.init;
    break :t &[_][]const Syntax {
        &.{
            x(.parens, .l, "`( $ `)"),
            x(.@"if",  .r, "`if $ `then $ `else $"),
        },
        &.{
            x(.add,    .l, "$ `+ $"),
            x(.sub,    .l, "$ `- $"),
        },
        &.{
            x(.mul,    .l, "$ `* $"),
            x(.div,    .l, "$ `/ $"),
            x(.mod,    .l, "$ `% $"),
        },
    };
};

fn comptimeStringSet(comptime list: []const []const u8) type {
    comptime {
        // manipulate so it's consumable by ComptimeStringMap
        const KV = struct {
            @"0": []const u8,
            @"1": void = {},
        };
        var kvs: [list.len]KV = undefined;
        for (list) |keyword, i| {
            kvs[i] = KV{ .@"0" = keyword };
        }

        return std.ComptimeStringMap(void, kvs);
    }
}

const KEYWORD_LIST = &[_][]const u8{
    "if", "then", "else", "def", "fn",
};

const SYMBOL_LIST = &[_][]const u8{
    "&", ".", "=", "::", "->", ",", ";", ":",
    // math
    "=", "+", "-", "*", "/", "%",
    // cond
    "==", ">", "<", ">=", "<=",
    // matched
    "(", ")", "[", "]", "{", "}", "|",
};

pub const KEYWORDS = comptimeStringSet(KEYWORD_LIST);
pub const SYMBOLS = comptimeStringSet(SYMBOL_LIST);

pub const MAX_SYMBOL_LEN = max: {
    var max: usize = 0;
    for (SYMBOL_LIST) |sym| {
        max = @max(max, sym.len);
    }

    break :max max;
};