//! datatypes for autogenerated parsing

const std = @import("std");
const builtin = @import("builtin");

pub const Form = enum {
    // special
    file,
    list,
    unit,
    parens,

    // general ops
    dot,

    // math
    add,
    sub,
    mul,
    div,
    mod,

    // conditions
    eq,
    gt,
    lt,
    ge,
    le,

    // flow
    stmt,
    @"if",
};

pub const Precedence = struct {
    power: usize,
    /// for binary ops
    right: bool = false,
};

/// used by parseForm to encode syntax
pub const FormExpr = union(enum) {
    expr,
    keyword: []const u8,
};

pub const Syntax = struct {
    const Self = @This();

    pub const Kind = enum { prefixed, binary };

    form: Form,
    prec: Precedence,
    fexprs: []const FormExpr,
    kind: Kind,

    fn init(form: Form, prec: Precedence, comptime str: []const u8) Self {
        const fexprs = &parseFormExprs(str);
        std.debug.assert(fexprs.len > 0);

        const is_binary = fexprs.len == 3
                      and fexprs[0] == .expr
                      and fexprs[1] == .keyword
                      and fexprs[2] == .expr;

        // otherwise, must be prefixed
        if (!is_binary and fexprs[0] != .keyword) {
            @compileError("I don't understand this syntax: `" ++ str ++ "`");
        }

        return Self{
            .form = form,
            .prec = prec,
            .fexprs = fexprs,
            .kind = if (is_binary) .binary else .prefixed,
        };
    }
};

pub const KEYWORDS = kw: {
    const list = [_][]const u8{
        ".", ";", "=",
        // math
        "+", "-", "*", "/", "%",
        // comparisons
        "==", ">", "<", ">=", "<=",
        // parens
        "(", ")",
        // lists
        "[", "]",
        // if
        "if", "then", "else"
    };

    // manipulate so it's consumable by ComptimeStringMap
    const KV = struct {
        @"0": []const u8,
        @"1": void = {},
    };
    var kvs: [list.len]KV = undefined;
    for (list) |keyword, i| {
        kvs[i] = KV{ .@"0" = keyword };
    }

    break :kw std.ComptimeStringMap(void, kvs);
};

fn countFormExprs(comptime str: []const u8) usize {
    comptime {
        var count: usize = 0;
        var iter = std.mem.tokenize(u8, str, " ");
        while (iter.next() != null) {
            count += 1;
        }

        return count;
    }
}

/// parses a formexpr at comptime.
/// this is a series of keywords and `<exprs>`
fn parseFormExprs(comptime str: []const u8) [countFormExprs(str)]FormExpr {
    comptime {
        _ = KEYWORDS;

        @setEvalBranchQuota(10_000);

        var fexprs: [countFormExprs(str)]FormExpr = undefined;
        var i: usize = 0;

        var iter = std.mem.tokenize(u8, str, " ");
        while (iter.next()) |tok| : (i += 1) {
            if (tok[0] == '<' and tok[tok.len - 1] == '>') {
                fexprs[i] = .expr;
            } else {
                if (!KEYWORDS.has(tok)) {
                    @compileError("`" ++ tok ++ "`is not a  keyword");
                }

                fexprs[i] = .{ .keyword = tok };
            }
        }

        return fexprs;
    }
}

/// the definition of fluent syntax
/// (this is a [_]Syntax)
pub const SYNTAX_TABLE = table: {
    // precedences
    const P = Precedence;

    const NONE           = P{ .power = 0 };
    const STATEMENT      = P{ .power = 1, .right = true };
    const COMPARISON     = P{ .power = 2 };
    const ADDITIVE       = P{ .power = 3 };
    const MULTIPLICATIVE = P{ .power = 4 };
    const FIELD_ACCESS   = P{ .power = 5, .right = true };

    // syntax definitions
    const x = Syntax.init;
    break :table [_]Syntax{
        x(.unit,  NONE,           "( )"),
        x(.@"if", NONE,           "if <> then <> else <>"),

        x(.stmt,  STATEMENT,      "<> ; <>"),

        x(.eq,    COMPARISON,     "<> == <>"),
        x(.gt,    COMPARISON,     "<> > <>"),
        x(.lt,    COMPARISON,     "<> < <>"),
        x(.ge,    COMPARISON,     "<> >= <>"),
        x(.le,    COMPARISON,     "<> <= <>"),

        x(.add,   ADDITIVE,       "<> + <>"),
        x(.sub,   ADDITIVE,       "<> - <>"),

        x(.mul,   MULTIPLICATIVE, "<> * <>"),
        x(.div,   MULTIPLICATIVE, "<> / <>"),
        x(.mod,   MULTIPLICATIVE, "<> % <>"),

        x(.dot,   FIELD_ACCESS,   "<> . <>"),
    };
};

fn tableWhereCount(comptime kind: Syntax.Kind) usize {
    comptime {
        _ = SYNTAX_TABLE;

        // count entries
        var count: usize = 0;
        for (SYNTAX_TABLE) |syntax| {
            count += @boolToInt(syntax.kind == kind);
        }

        return count;
    }
}

fn tableWhere(comptime kind: Syntax.Kind) [tableWhereCount(kind)]Syntax {
    comptime {
        _ = SYNTAX_TABLE;

        const count = tableWhereCount(kind);

        var arr: [count]Syntax = undefined;
        var i: usize = 0;
        for (SYNTAX_TABLE) |syntax| {
            if (syntax.kind == kind) {
                arr[i] = syntax;
                i += 1;
            }
        }

        return arr;
    }
}

/// a ComptimeStringMap(Syntax) where the key is the prefix keyword
pub const PREFIXED_SYNTAX = map: {
    const arr = tableWhere(.prefixed);

    const KV = struct {
        @"0": []const u8,
        @"1": Syntax,
    };

    var kvs: [arr.len]KV = undefined;
    for (arr) |syntax, i| {
        kvs[i] = KV{
            .@"0" = syntax.fexprs[0].keyword,
            .@"1" = syntax,
        };
    }

    break :map std.ComptimeStringMap(Syntax, kvs);
};

/// a ComptimeStringMap(Syntax) where the key is the binary operator keyword
pub const BINARY_SYNTAX = map: {
    const arr = tableWhere(.binary);

    const KV = struct {
        @"0": []const u8,
        @"1": Syntax,
    };

    var kvs: [arr.len]KV = undefined;
    for (arr) |syntax, i| {
        kvs[i] = KV{
            .@"0" = syntax.fexprs[1].keyword,
            .@"1" = syntax,
        };
    }

    break :map std.ComptimeStringMap(Syntax, kvs);
};